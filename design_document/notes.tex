
\subsection{Entity Manager}
\lstinputlisting[language=cpp, caption=entity\_manager.cpp]{../code_samples/entity_manager.cpp}
    \subsubsection{How do we organize caching of read dependencies?, yes, maybe}
    \subsubsection{We do not have to deal with order dependencies. No}
    \subsubsection{How do we deal with components deactivating?, just swap with the back and increment generation?}
        \subsubsection{Maybe we then need individual generations per component "space", not per type}

\subsection{Standard Components}
    \subsubsection{Child Component}
    \subsubsection{Parent Component?}

\subsection{Actor Events}
    \subsubsection{Children being attached can be events}
    \subsubsection{Components being attached can be events?}

\subsection{Factory}

\subsection{}

In EntityMananger allow all steps to be called from the outside.

Write more on OperationTypes

    // Lifecycle:                                   States:
    //                                              Raw memory 
    // constructor -> (optionally initialize) ->    Hibernate 
    // onAwake ->                                   Inactive
    // onActivate ->                                Simulated
    // onDeactivate ->                              Inactive
    // onHibernate ->                               Hibernate
    // destructor ->                                Raw memory

    // State changes are async and are requested through the ECS.
    // Activation, Deactivation are async

Magnus - PMS log on actor system:
Du, slik jeg forstod event systemet deres, s친 var det ikke noen crossover mellom actor events og vanlige events?
Alts친, actors og components h칮rer kun p친 actor events right? Eller h칮rer de p친 engine events ogs친?

Hovedsaklig actor events, men det er ingenting som hindrer dem i 친 lytte p친 andre events. Mulig det i praksis bare er actor events.
Aight. Men sender dere andre ting enn actor events ut av components?

SceneNodeEvent f.eks.
S친 ja.
Men det ligger i application laget right, s친 de vet ikke noe om actors og components?

Nei, logic. Men selve eventsa bryr seg ikke om actors.
Vel, actor eventsa bryr seg om actors, men det gj칮r ikke "component" eventsa?
jeg mener application eventsa.
Bare pr칮ver 친 finne ut hvordan man kan interface mot dette her n친r vi effektivt ikke har noen actor 游땥

Alts친. Det finnes ikke application events. Events er bare i logic. Actor events bryr seg s친 klart om actors, men andre events gj칮r det ikke. Tror ikke det eksisterer events som ikke er actor events som har noe direkte med actors 친  gj칮re. Sp칮rs hva du mener med "actor events" og "component events".
Ah right, jeg som har missforst친tt litt da.
Greit, da er det muligheter for at det blir et st칮rre skille mellom actor events og vanlige events i systemet v친rt 游땥
Det burde g친 fint, s친 lenge components ogs친 kan sende ut vanlige events, og motta events fra andre systemer retta spesifikt mot dem.
Jaja, det skal vi klare 친 f친 p친 plass p친 et eller annet vis 游땥
Hehe, good 游

Det andre jeg da lurer p친 er
Jeg ser at det virker som om dere queuer events i actor systemet ogs친 s친nn i world.
Er det da events til andre komponenter, og n친r queuer dere fremfor direkte funksjonskall?

Jupp, slike events blir sendt til alle components under actoren.
Tror de sendes direkte da, alts친 ingen queue. Om du ser p친 Actor::broadcastComponentEvent, tror jeg
Vi bruker events fremfor funksjonskall n친r vi ikke vil lage sterke knytninger mellom comonents. Slik at du f.eks. kan ha en mer generell hendelse som kan h친ndteres p친 ulike m친ter basert p친 hvilke components den har.
Men, actors gj칮r det direkte funksjonskallet for deg right?
for deg mener jeg. I allefall slik som jeg ser det n친.
Ja, stemmer.

Men, det er ikke noen order dependencies n친r dere gj칮r event handlingen, og det er ingenting i veien for at den er async?

Er usikker p친 det. Men om det er order dependencies s친 vil jeg tro koden kan skrives om.
Det er s친nn jeg tolker det fordi dere bruker jo unordered map, s친 dere har jo ingen garantier.

Men det er bare for 친 hente components. Updaten og broadcastinga f.eks. skjer med en vector. Men det er heller ingen garanti for hvilken rekkef칮lge actors ligger der.
Alright, s친 annet enn med child-actors s친 er det egentlig ikke noen order dependencies i update loops? I allefall ikke harde?

Nope.
Slik jeg forst친r motoren deres, s친 lar dere ogs친 hver eneste oppdatering gj칮re seg helt ferdig right? Det er ikke s친nn at dere stopper med 친 prosessere events fordi dere starter 친 f친 d친rlig tid eller noe liksom?

Nei, stemmer.
Awesome, du har akkurat gjort min jobb litt lettere 游땥, tror jeg.

Er det normalt at componenter sender beskjeder til andre komponenter som ikke tilh칮rer samme actor?
Og, har dere da en s친nn mottaker id?
14:54

Ikke s칝rlig normalt, men mulig at vi har gjort det. Kommer ikke p친 noen tilfeller.
Ingen konkret mottaker ID, men Actor* som sendes med indentifiserer ofte hvem som skal motta den.
Aight, men ikke noen m친te 친 indikere sender?

M친 lage en ny event klasse som arver og har en ekstra peker eller ID. Har gjort det noen ganger for spesifike events.
I spillkode.
Ah, alright.
Hva exakt er det dere bruker OnDestroy til? Brukes det fremfor en destructor, eller er det noen ganger dere 칮nsker 친 "destroye" et objekt uten 친 deallocatere det minnet?

Det siste. Det er en state hvor Actoren og staten dens holdes i minnet, men p친 en m친te kobles ut fra verden. Den kan s친 lages om igjen med samme staten. I motsetning s친 er inactive Actors fortsatt en del av verden, s친 de har f.eks. koblinger til andre Actors, lydsystem, grafikk, etc.
S친, disabled actors f친r fortsatt updaten sin kj칮r eller?

Nei, de har koblinger men er fryst.
S친 de kan motta events for 친 bli reaktivert liksom?

Kan det, men vi fjerner ofte listeners n친r de deaktiveres. Det er ikke n칮dvendig da.
S친 hva er da egentlig forskjell p친 en destroyed component og en inactive component? Virker litt vagt?

Sett fra enginen sin side: ingentig. Det sp칮rs helt hvordan du implementerer funksjonene i componentsa. Poenget er at activate/deactivate er mye lettere transitions enn create/destroy, s친 om de ikke skal v칝re inaktive lenge, s친 b칮r de bare deaktiveres, men om de skal v칝re inaktive lenge s친 kan de destroyes for 친 spare minne og noe CPU. F.eks. s친 vil en inaktiv ActorPhysics ha en Box2D body, men som er insktiv. Om den er destroyed s친 fjernes hele Box2D bodien.

Lurer ogs친 p친 om destroyed Actors fjernes fra update vectoren. Usikker.
Hmm, jeg f친r litt inntrykk av at den faktisk blir fjernet effektivt s친nn egentlig?
Eller tar jeg feil?
Men ok, s친 en destroyed actor er egentlig bare en actor som er inaktiv over lengre tid?

Den sletter de ikke, s친 verdiene til variablene bevares.
S친 hvordan g친r dere da frem for 친 faktisk slette en component?

Den kan slettes etter destroy p친 vanlig m친te. Alts친 unique_ptr'en fjernes.
Men, n친r dere destroyer en component, s친 kan den bringes tilbake til live igjen, med alle variablene den hadde.

Ja, navna forvirrer kanskje. Destroy og sletting er forskjellig ting. N친r en Actor er destroyed, s친  er den i minnet fortsatt. S친 kan den slettes fra minnet. Destroyed er det samme f칮r created. Alts친 n친r du lager en Actor med en unique_ptr s친 er den destroyed. S친 kj칮rer du create for 친 create den. Det er nesten likt som i Android med onCreate og onDestroy. Den kan fortsatt v칝re i minnet selv om den er destroyed.

"det samme som f칮r created"*
Alright, s친 det burde kanskje heller v칝rt beskrevet p친 f칮lgende m친te: 
R친tt minne -> OnCreate -> OnActivate -> OnDeactivate -> Hibernate -> R친tt minne
Eller, det kan beskrives p친 f칮lgende m친te*

Ja, men hibernate burde v칝re onDestroy (slik det er n친), eller s친 burde onCreate v칝re onWake elns..
Den er grei, da henger jeg med.
Men, dersom du 칮nsker 친 slette noe (ikke bare destroy, men slette), s친 m친 du fortsatt si ifra til world da?

Ja.
Er en funksjon der du m친 kalle. Husker ikke navnet.
Alright, men da er det fortsatt manuell memory management 친 fjerne components som er destroyed, det jeg lurte p친 游뗵
"manuell"

Ja.
Alright, awesome, dere 칮nsker fortsatt 친 ha den lifssyklusen?

Jeg tror det er lurt, eller har du andre meninger?
Dersom dere ikke har noen spesielle 칮nsker s친 beholder vi den bare, ville bare ha litt klarhet i logikken 游뗵
Nei, er ikke noe galt med den, var bare dersom dere hadde noen andre tanker kunne vi sikkert tittet litt rundt.

OK, cool.
Bra vi fikk klarhet 游땥
Men, alt av aktivering og deaktivering og destroying etc, det skjer async? Potensielt ogs친 gjennom events?

Nei, det skjer direkte gjennom funksjonskall.
Kan det skje async gjennom events?
:P

Tja, om en component deaktiverer en Actor i et event callback. Det er ingen events som spesifikt deaktiverer en Actor.
Fordi ja, currently s친 ser det faktisk ut som at actors egentlig ikke kommer til 친 eksistere, kun components som deler id.
Men, grunnen til at jeg lurer p친 om det kan gj칮res async, er at det vil gj칮re det ganske mye lettere 친 parallelisere og batche updates.

Fordi ja, currently s친 ser det faktisk ut som at actors egentlig ikke kommer til 친 eksistere, kun components som deler id.
Men, grunnen til at jeg lurer p친 om det kan gj칮res async, er at det vil gj칮re det ganske mye lettere 친 parallelisere og batche updates.

Det burde g친 fint. Ser ikke noe problem.
Alright nice. Da starter faktisk mange av de forskjellige brikkene 친 falle p친 plass tror jeg.
