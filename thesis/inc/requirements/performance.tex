\section{Performance}

\subsection{Virtual Functions}
Virtual functions is C++'s way of supporting dynamic function binding,
allowing for run-time polymorphism.
With the help of virtual functions, objects derived from a base class
can override base class functionality, even when derived's type is unknown at compile time.
The implementation of virtual functions are not mandated by the C++ ISO Standard \todo{Link to standard (c++14 or c++17)?, Ask Mariusz if draft is ok, as the real thing costs money}
however many compilers choose the same tactic; creating a virtual table.
A virtual table can be viewed as a data structure containing function pointers to the virtual functions to be called in a derived class.
Each instance of an object is then given a hidden member variable, which is a pointer to their classes respective virtual table.
When a virtual function is invoked the virtual table pointer is used to look up which function that should be run.
The virtual table pointer can be placed anywhere, but is usually either the first or last member of an object.
Multiple inheritance is often implemented by adding more virtual tables and virtual table pointers.
\todo{List compilers that implement virtuals with vtables? Add sources, for example: http://lazarenko.me/devirtualization/, https://web.archive.org/web/20110725153606/http://www.codesourcery.com/public/cxx-abi/cxx-closed.html, http://wayback.archive.org/web/20100209040010/http://www.codersource.net/published/view/325/virtual\_functions\_in.aspx, and https://en.wikipedia.org/wiki/Virtual\_method\_table}

The introduction of a hidden member variable adds a certain space overhead for each instance of a polymorphic class.
The exact space overhead of implementation is influenced by some factors, the size of a pointer within the given architecture, the number of base classes, as well as the total alignment requirement of the class.
Invoking a virtual function also adds some overhead in terms of extra lookups, the severity varies between architectures, as well as from situation to situation.
The overhead can for example be influenced by whether or not the function is in the CPU's cache,
if the CPU has done a branch miss-prediction, which can force a CPU flush, and pipeline stall.
As a result of virtual functions being invoked at runtime, the compiler might only see the invocation as an opaque function call, possibly disabling certain optimizations like inlining, reordering, compile time calculations, or even removing empty function calls. \todo{Clear this with Mariusz and others knowledgeable with C++}
These tradeoffs are known, and compilers can to a certain degree optimize away some of these issues.
For example if a type is known at compile time, then a compiler might do devirtualization, meaning that it will not do a lookup through a virtual pointer table, but rather do a direct function call.
\todo{Add sources: http://gameprogrammingpatterns.com/data-locality.html,
https://www.youtube.com/watch?v=WDIkqP4JbkE,
Also find more sources for devirtualization:
https://www.youtube.com/watch?v=lQAxldEGOys}

Direct run-time polymorphism is rarely needed within the NOX engine, especially within the entity systems.
As a result of this Suttung and the authors decided to try and find another mechanism for handling "polymorphic" behavior.

\subsection{Contiguous Memory}

\subsection{Multi-threading}
