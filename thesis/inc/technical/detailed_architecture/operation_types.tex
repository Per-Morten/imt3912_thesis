\section{Operation Types}
\label{subsec:detailed_operation_types}
Operation types are the way NOX ECS handles overridable component behavior; they are different function pointers held within the meta information of a component type.
The various operation types points to functions that should be called during the different steps
of a components lifecycle.
This functionality would normally be supported using virtual functions in C++.

Additionally, the operation types are used to support limited component construction, destruction, move construction and move assignment without directly needing to know the subject component type.
Being able to construct, move construct or move assign a class without knowing it's type
is something we have not found C++ support for.

\subsection{Motivation}
The main motivation behind the operation types structure was the requirements restriction on virtuals\reqref{req:virtuals}
and templates\reqref{req:templates}.
NOX ECS would need a way to keep track of overridable behavior of a component type, without the overhead of virtuals,
and without directly knowing the component type.

Additionally, there was a desire to allow the users more flexibility when creating their lifecycle functions.
This flexibility would include the ability to take advantage of known data patterns,
alternatively, use generic non-member functions to implement component behavior.
By default, the operation types would be "invisible" to the user of the ECS, allowing them to think in a regular member function object oriented mindset.

\subsection{Explanation}
Operation types are pointers to functions that take in Component pointers,
and potentially some other parameters.
Functions implementing the operation types will cast the Component pointer parameter over to the derived type,
and call the derived function.
This allows for overridable behavior without the per instance space overhead of a pointer to the virtual table.

This idea of having functions taking opaque types only to cast them over to the correct types is nothing new.
This line of thought was what allowed users to send in their own compare functions to C's qsort function\footnote{\url{http://en.cppreference.com/w/c/algorithm/qsort}}.

Additionally, some of these operation types were created for operating on contiguous ranges of component types,
allowing users to iterate over components and take advantage of known data patterns or caching of calculated values.

\subsubsection{Wrapper Functions}
Writing all these "conversion" functions out by hand is way too tedious and error prone, and would go against the "opt-in" philosophy of the NOX ECS.
The user should normally not need to worry about correct casting or pointer iteration but work with the mindset and semantics that they are used to, i.e. thinking with member functions.

This problem was solved with the help of C++ templates.
When the user is calling the create meta information for a specific component type,
the component type is sent in as a template parameter.
This allows us to create template instantiations of wrapper functions that do the standard conversions.
An example of this is seen in listings \ref{lst:create_meta_information_wrapper}.
\lstinputlisting[language=cpp, caption=Create Meta Information Wrapper Functions, label=lst:create_meta_information_wrapper]{create_meta_information_code/create_meta_information_wrapper.cpp}

\subsubsection{Overload Detection}
In addition to creating wrappers for the operation types, using templates in this situation
allows NOX ECS to detect whether or not functions are actually overloaded\footnote{Technically this is really hiding, rather than overloaded, however, since we use it logically to mean overload, we use the term overload rather than hiding}.
This is done by comparing the function signatures of the component base class against the function signatures of the derived type.
Member functions within C++ has the class the function belongs to as its first parameter\cite{iso_cpp_member_function_pointers},
this signature change can be used to compare the two functions against each other using C++ type traits, and std::enable\_if.
The implementation of this functionality can be see in listing \ref{lst:create_meta_information_overload_detection}

\lstinputlisting[language=cpp, caption=Create Meta Information Overload Detection, label=lst:create_meta_information_overload_detection]{create_meta_information_code/create_meta_information_overload_detection.cpp}

\subsubsection{Template Justification}
Using templates here seems to go against the earlier requirement of avoiding heavy template usage\reqref{req:templates}.
In this case it is justified by the fact that calling the create meta information function is usually only done in one file.
Additionally this function does not impact any internal workings of NOX ECS, meaning that no recompilation is needed for the NOX ECS when
a template parameter is changed for this function.

\subsection{Alternatives To Operation Types}
The common solutions for the problem of reusability and overridable behavior would be the template or virtual functionality in C++.
When heavy usage of both of these features is ruled out due to the requirements, there are not that many obvious alternatives left, at least not without changing some of the other architectural choices.

\subsection{Pros of Operation Types}
The operation types solution does offer certain advantages over the potential alternatives of templates and virtual functions.

\subsubsection{Greater Customization Options}
Regular virtual functions in C++ are implemented as member functions, requiring the user to couple functions with their data.
Operation types work on free standing functions, which by default are wrappers that call member functions.
However, the user can if desired supply their functions to the function pointers.
For example pointers to template instantiations of functions allowing the user to write generic functions that can operate on different types of components, still optimized for their respective types.
Keeping the operation types as pointers to free standing functions also means that there is not such a push towards coupling functions and data together, as member function syntax is not required.

\subsubsection{Contiguous Iteration}
Some of the operation types are created to work on ranges of components, mainly the update and receive event operations.
This decision was made to allow the users of the system to take advantage of potential known data patterns within the components, leading to more efficient code.
It also gives a larger chance of the CPU keeping the pointer to the overridden function in the cache, as all components that are sent into an operation will be of the same type.

\subsubsection{Removal of Unused Functions}
Regular virtual functions in C++ can be hard for the compiler to optimize away.
The exception being if the type can be known during compile time.
C++ does not offer any Just In Time compilation either, meaning that even calls to empty virtual functions cannot be removed.
This is possible with the operation types, as there are just regular function pointers, they can be checked for nullptr.
This feature is offered by default within the NOX ECS, which is able to detect overriding of functions within a derived type.

\subsubsection{No Virtual Pointer Space Overhead}
While the operation types still incur some run-time overhead regarding indirection, the per type space overhead of a virtual table pointer is gone.

\subsection{Cons Of Operation Types}
\subsubsection{Burdens on Users}
While the programmer does not need to worry about how the operation types works by default,
some extra burdens are put on the programmers that wish to take advantage of the flexibility offered.

\paragraph{Casting}
Because the ECS is unaware of the types it is directly working with, a certain level of type casting is required.
Each operation type receives some component pointers that must be casted over to the correct type, and possibly iterated over.
This is a lot of boilerplate, and it can be difficult to debug if done wrong. This type of casting can be seen in listing \ref{lst:create_meta_information_wrapper}.

\paragraph{Non-regular Syntax}
Working only with operation types internally within the ECS means that one moves away from the normal syntax of C++.
For example, move assignment operators are replaced with function calls to the move assignment operation type.
This is not visible to the end user but is something possible maintainers will have to get used to when working with the ECS.

\subsubsection{Optimization Limitations}
Since the operation types are replacements for certain functionality that is built into C++, the compiler is in
unfamiliar territory, leading to potential lost optimization opportunities.
For example, certain types may be faster to copy than to move, unfortunately the ECS only support move constructors and move assignment operators.
The decision to go with move-only types is that it can be faster for types that are costly to copy, and also because of the existing use patterns that are used within the old NOX actor system, where components also are move-only types.
Other optimizations opportunities are also limited, for example, removal of destructor calls on trivial types.

\subsubsection{Levels of Indirection}
Normal virtual functions in C++ normally have two levels of indirection, one for looking up the virtual table, and one for looking up a function that is pointed to within the virtual table.
This cost can diminish over time if the user can ensure that objects with the same virtual function overloads are processed in an ordered sequence based on their types, allowing for virtual functions to be cached.
The operation types offers the same levels of indirection, with a possibility of an extra indirection.
The first indirection will be to find the meta information structure belonging to a component collection, then another layer of indirection to find the function that an operation type is pointing to.
If the function pointed to is a default wrapper that calls a member function there might be another layer of indirection if the member function is not inlined by the compiler.
This function could then be kept in cache for the functions that are called on ranges of values.
