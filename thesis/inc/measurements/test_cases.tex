\section{Test Cases}

\subsection{Purpose}
The purpose of the tests are to measure and quantify the different types of optimizations and choices that has been made to the ECS.
The results of each test is supposed to give an idea as to how well the ECS system compares to the original nox engine in a couple of different cases.

\subsection{Changes}
In the original test case plan\todo{Add reference here} there were a couple of requirements and goals that were not achieved or changed.

\subsection{Compiler}
These include the fact that only the GCC compiler was used, instead of three which also included Clang and MSVC to be used in the test cases.
The decision to leave those two compilers out was mainly due to time constraints, as the time it took to run all the tests was already taking a couple of days with only GCC.



\subsection{Tools}


\subsection{Profiler}
Valgrind
- massif
- cachegrind
- callgrind


\subsection{Platforms}
The plan was to run all the tests both on windows and linux, and if there was additional time, also run it on mobile which is an important platform for Suttong.
There were unfortunately not enough time to make sure the tests run properly on windows, and actually running them on windows.


\subsection{Trivial Component}
The trivial component is meant to serve the function of a component that does some work, which also involves using the event system.
It is used for the numerous unique component and multi thread support test cases.
Each trivial component will in every update call, potentially send an event based on its waiting duration, and that wait for as long as the wait duration lasts.
The wait simulates work, and the messages sent is the use of the event system that is wanted in the tests.


\subsection{Different Test Optimizations}
All 14?
holy crap


\subsection{Compilation Test}

\paragraph{Reason}
The reason there was a need for a compilation test, was because the time spent compiling the engine was of importance for Sutting.
It was desirable for the time spent compiling would not increase by a significant amount with the addition of the ECS.

\paragraph{Flaws}
There is one major flaw with this test, and it is that it can't be performed without heavy restructuring of the code base.
The ECS is tightly coupled with the Nox Engine in the sense that a significant amount of the original code is still used in the ECS.
This means that if you compile the ECS, you also have to compile the Nox Engine.
However, it would be very difficult and time consuming to extract exactly the code needed for the ECS to avoid this problem.
A way around this could be to first compile the Nox Engine and the ECS.
Then measure and compare the compilation duration for the nox tests and ecs tests.
Unfortunately for reasons unknown, it is not possible to partly compile the project in this manner.

\paragraph{Method}
The test would be performed by first clearing all old build files by simply erasing the build directory.
Then the compilation is run in conjunction with the bash shell command time to measure the duration.

\subsection{Fast Spawning}
\paragraph{Reason}
The fast spawning test was created in order to see if the ECS could improve on the lacking performance Nox Engine has when spawning a lot of actors at once.

\paragraph{Flaws}
As a result of the physics module not being implemented in the ECS, the physics components never got any testing in the ECS, and therefore the nox version was never compared against.
The reason for leaving out the physics component is that the whole physics module in the Nox Engine is so tightly coupled with it, that refactoring it for the ECS was not prioritized.

\paragraph{Method}
The fast spawning test case is performed by spawning a set amount of actors as fast as possible, and then deleting them all.
This spawn and delete can happen two different amount of times, once or ten times depending on the test.
The different amounts of actors in the tests are as defined by this function.

\begin{equation}
x = \sum_{n=8}^{16} 2^{n}
\end{equation}

This results in a sequence of actor counts going from 256, and increasing with an exponential growth until it reaches 32768.

\paragraph{Changes}
The test case was executed as described in the plan to a large degree, except that there were no tests involving empty actors, as it is of no interest to compare between the Nox Engine and ECS when there is no actual entity object in the ECS to take up memory, which there are in the Nox Engine.

\subsection{Numerous Unique Components and Multi Threading Support}
\paragraph{Reason}
This test case was created because the ECS needed to support both a large amount of different component types at once, and have efficient multi threading.
It puts pressure both on how many component types the system can handle, but also the event system as every component sends a large amount of events.

\paragraph{Flaws}
The fact that the numerous unique components and multi threading support are combined makes it harder to s

\paragraph{Method}
\paragraph{Changes}

\subsection{Memory Usage}
\paragraph{Reason}
This case is used to measure how much memory each system uses with either sprite or transform components.

\paragraph{Flaws}
There is a problem with measuring and comparing the amount of memory the different components are using, when each systems does not give the same amount of functionality.
However, even though the ECS does not support all features available in the Nox Engine, it still uses a considerable less amount of memory.
It does this to a degree where it most likely won't catch up to the Nox Engine even when including the missing features.

\paragraph{Method}
The method for performing this test involves creating a set amount of actors with the same numbers mentioned in the fast spawning section above.
These actors will either be transform or sprite actors depending on the test.
The test will run for a minimum of one second, and then quit.

\paragraph{Changes}
All of the cases mentioned in the test case plan were not done.
Instead there were two cases that were tested, with sprite actors and transform actors.
The cases in the plan were abandoned either for not fitting with the ECS, namely the empty actors case, or being too time consuming which was the case for the deep scenegraph.

\subsection{Thread Safe Logging}
\paragraph{Reason}
Needed a way to ensure the attempt at making the old logging system thread safe does what it is supposed to.

\paragraph{Flaws}
No apparent flaws in the test case.
This can mostly be contributed to the fact that the problem at hand was not very difficult.
The addition of a mutex in the logging system made it thread safe, and the way to ensure it was, also provides a strong case.

\paragraph{Method}
Each thread in the test will constantly print out the letter a through z for a given amount of time.
If the logger was not thread safe, there would be a inconsistency where the letter a starts again too early, because a thread has been cut off in the middle of printing.
After the program has run for a sufficient amount of time, the output is checked to see if any such previously mentioned errors has occurred.
If there is no such errors, the logger can be considered thread safe.

\paragraph{Changes}
This test was done drastically different, due to it becoming apparent how much easier it can be performed.
First off, there is no need for a ton of components doing this work of sending messages to put stress on the logging system, a couple of threads sending messages are more than fine.
In addition, instead of using a regex check to see if every line is correct, the test was simply ran once with a single thread so no races could occur.
After that the actual test was run, and the result of the single and multi threaded tests were checked to be equal, and if they were the test was a success.
