\section{Test Cases}

\subsection{Purpose}
The purpose of the tests are to measure and quantify the different types of optimizations and choices that has been made to the ECS.
The results of each test is supposed to give an idea as to how well the ECS system compares to the original nox engine in a couple of different cases.

\subsection{Changes}
In the original test case plan\todo{Add reference here} there were a couple of requirements and goals that were not achieved or changed.

\subsection{Compiler}
These include the fact that only the GCC compiler was used, instead of three which also included Clang and MSVC to be used in the test cases.
The decision to leave those two compilers out was mainly due to time constraints, as the time it took to run all the tests was already taking a couple of days with only GCC.



\subsection{Tools}


\subsection{Profiler}
Valgrind
- massif
- cachegrind
- callgrind


\subsection{Platforms}
The plan was to run all the tests both on windows and linux, and if there was additional time, also run it on mobile which is an important platform for Suttong.
There were unfortunately not enough time to make sure the tests run properly on windows, and actually running them on windows.


\subsection{Trivial Component}
The trivial component is meant to serve the function of a component that does some work, which also involves using the event system.
It is used for the numerous unique component and multi thread support test cases.
Each trivial component will in every update call, potentially send an event based on its waiting duration, and that wait for as long as the wait duration lasts.
The wait simulates work, and the messages sent is the use of the event system that is wanted in the tests.


\subsection{Different Test Optimizations}
While not all the different optimizations that were done lent themselves perfect to testing, we
wanted to test some of them in isolation.
These tests were enabled by macros, where the ECS was running with its normal settings on
every case, except the one that was being tested.
This would allow us to see whether or not an optimization was worth the cost of implementation.

\subsubsection{Atomic Sequential Consistency}
The testing was done on a strongly ordered architecture, but we were still interested
in seeing whether or not there were any benefits to using relaxed atomics
on this architecture.

\subsubsection{Numeric Type Identifiers}
The type identifier system offers two different ways to identify types, using
hashed strings, or using numeric values.
We wanted to inspect the differences in performance of using strings, vs
using numeric types. We therefore added a macro which would turn
all the string values into strings, which would be hashed.

\subsubsection{Allocators}
Currently we have implemented 3 different allocators, the lock free allocator,
a locked linear allocator, and a heap allocator.
All three of these will be tested for the event arguments, while the
linear allocator and lock free allocator will be tested with the lock free stack.
The reason for only using the two allocators on the stack is that it requires
a linear allocator to avoid the ABA problem\footnote{Explained in p.\pageref{subpar:detailed_lock_free_allocator_aba}}.

\subsubsection{Locked vs Lock Free}
We used quite some time when implementing the lock free stack, and allocator.
As a result we wanted to see if these implementations were worth the time,
and added in tests were we would use the lock free stack or the locked queue
for handling events and lifecycle transitions.
We additionally added in a test case for using the lock free stack or locked queue
in the thread pool.

\subsubsection{Collection}
We will also test some alternatives within the component collection.

\paragraph{Virtual Usage}
In one of the tests the collections will function as normally, but
components will be using virtual functions, rather than the function pointers
from the meta information.

\paragraph{Unique Pointers}
The other case will be a more simple implementation of the collection,
in this case all the components will be allocated on the heap, and managed
using std::unique\_ptrs.
Virtual functions will also be used, rather than the meta information,
as we are not working with contiguous ranges. Additionally no partitioning is done.

\subsection{Execution Layers}
By default the ECS uses the execution layers for all the places it makes sense,
mainly the update step and distribution of events.
We wanted to test how much boost we would get from the execution layers,
and have therefore run tests where the different layered models were turned off.

\subsection{Compilation Test}

\paragraph{Reason}
The reason there was a need for a compilation test, was because the time spent compiling the engine was of importance for Sutting.
It was desirable for the time spent compiling would not increase by a significant amount with the addition of the ECS.

\paragraph{Flaws}
There is one major flaw with this test, and it is that it can't be performed without heavy restructuring of the code base.
The ECS is tightly coupled with the Nox Engine in the sense that a significant amount of the original code is still used in the ECS.
This means that if you compile the ECS, you also have to compile the Nox Engine.
However, it would be very difficult and time consuming to extract exactly the code needed for the ECS to avoid this problem.
A way around this could be to first compile the Nox Engine and the ECS.
Then measure and compare the compilation duration for the nox tests and ecs tests.
Unfortunately for reasons unknown, it is not possible to partly compile the project in this manner.

\paragraph{Method}
The test would be performed by first clearing all old build files by simply erasing the build directory.
Then the compilation is run in conjunction with the bash shell command time to measure the duration.

\subsection{Fast Spawning}
\paragraph{Reason}
The fast spawning test was created in order to see if the ECS could improve on the lacking performance Nox Engine has when spawning a lot of actors at once.

\paragraph{Flaws}
As a result of the physics module not being implemented in the ECS, the physics components never got any testing in the ECS, and therefore the nox version was never compared against.
The reason for leaving out the physics component is that the whole physics module in the Nox Engine is so tightly coupled with it, that refactoring it for the ECS was not prioritized.

\paragraph{Method}
The fast spawning test case is performed by spawning a set amount of actors as fast as possible, and then deleting them all.
This spawn and delete can happen two different amount of times, once or ten times depending on the test.
The different amounts of actors in the tests are as defined by this function.

\begin{equation}
x = \sum_{n=8}^{16} 2^{n}
\end{equation}

This results in a sequence of actor counts going from 256, and increasing with an exponential growth until it reaches 32768.

\paragraph{Changes}
The test case was executed as described in the plan to a large degree, except that there were no tests involving empty actors, as it is of no interest to compare between the Nox Engine and ECS when there is no actual entity object in the ECS to take up memory, which there are in the Nox Engine.

\subsection{Numerous Unique Components and Multi Threading Support}
\paragraph{Reason}
This test case was created because the ECS needed to support both a large amount of different component types at once, and have efficient multi threading.
It puts pressure both on how many component types the system can handle, but also the event system as every component sends a large amount of events.

\paragraph{Flaws}
The fact that the numerous unique components and multi threading support are combined makes it harder to s

\paragraph{Method}
\paragraph{Changes}

\subsection{Memory Usage}
\paragraph{Reason}
This case is used to measure how much memory each system uses with either sprite or transform components.

\paragraph{Flaws}
There is a problem with measuring and comparing the amount of memory the different components are using, when each systems does not give the same amount of functionality.
However, even though the ECS does not support all features available in the Nox Engine, it still uses a considerable less amount of memory.
It does this to a degree where it most likely won't catch up to the Nox Engine even when including the missing features.

\paragraph{Method}
The method for performing this test involves creating a set amount of actors with the same numbers mentioned in the fast spawning section above.
These actors will either be transform or sprite actors depending on the test.
The test will run for a minimum of one second, and then quit.

\paragraph{Changes}
All of the cases mentioned in the test case plan were not done.
Instead there were two cases that were tested, with sprite actors and transform actors.
The cases in the plan were abandoned either for not fitting with the ECS, namely the empty actors case, or being too time consuming which was the case for the deep scenegraph.

\subsection{Thread Safe Logging}
\paragraph{Reason}
Needed a way to ensure the attempt at making the old logging system thread safe does what it is supposed to.

\paragraph{Flaws}
No apparent flaws in the test case.
This can mostly be contributed to the fact that the problem at hand was not very difficult.
The addition of a mutex in the logging system made it thread safe, and the way to ensure it was, also provides a strong case.

\paragraph{Method}
Each thread in the test will constantly print out the letter a through z for a given amount of time.
If the logger was not thread safe, there would be a inconsistency where the letter a starts again too early, because a thread has been cut off in the middle of printing.
After the program has run for a sufficient amount of time, the output is checked to see if any such previously mentioned errors has occurred.
If there is no such errors, the logger can be considered thread safe.

\paragraph{Changes}
This test was done drastically different, due to it becoming apparent how much easier it can be performed.
First off, there is no need for a ton of components doing this work of sending messages to put stress on the logging system, a couple of threads sending messages are more than fine.
In addition, instead of using a regex check to see if every line is correct, the test was simply ran once with a single thread so no races could occur.
After that the actual test was run, and the result of the single and multi threaded tests were checked to be equal, and if they were the test was a success.
