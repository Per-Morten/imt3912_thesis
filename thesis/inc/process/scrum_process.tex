\section{Scrum Process}
We followed a scrum like process throughout the development of the project.
Scrum meetings were held each day, in which we both used 5-15 minutes to update each
other on the previous workday, our current plans for the day, and potential
problems we had identified that could harm our progress.
This was done to ensure that both members had a proper understanding of what the other
member was doing.
Sprint retrospectives were done biweekly, however these meetings were dropped when
we started working on thesis and finishing the project in parallel.
The retrospectives can be found in appendix \ref{chap:appendix_sprint_retrospectives}.
After each finished sprint, the next sprint was planned, and we would start setting
up the tasks/issues for the new sprint.
The tasks were prioritized mostly based on what seemed most beneficial, nonetheless we were both
ready to re-prioritize tasks if needed.
Tasks were also tracked through Github's project board, with a simple scheme of: "todo",
"under development", "review ready", and "done".
The issue tracking system essentially became the project backlog, and
each milestone became a sprint backlog.

\section{Development Workflow}
\subsection{Branching Strategies}
Throughout the project we followed an issue branching git workflow.
Here we would create a new branch in git for each issue/task we were working with,
when a task was finished we would make a pull request to parent branch, usually master.
The pull request would be reviewed by the team member, any comments from the reviewer
would need to be justified, or fixed before the branch was merged.
This allowed us to isolate our work in a relatively clean matter, but
it did lead to smaller problems when certain branches started depending on each other.
The branches were named according to the issues, and all commits were tied to these
with the use of the issue tracker.
Additionally, we did not allow for fast forward merges to parent branch, as we wanted
keep a more accurate development history.

\subsection{Commits}
We employed a commit message format scheme to ensure a certain quality of the commit messages.
The format forced us to tie our commits to different issues, and give a short description of the commit.
If a commit needed more explanation the extra field below the header was used,
allowing a for a more detailed description of the commit, and potential references to other issues.
The message would start with a reference or potentially fix to the relevant issue,
followed by the commit header and a new line.
No matching was done for the explanatory body.
A regex was placed in a git hook which would launch when running the git commit command, the regex can be seen in listing~\ref{lst:commit_msg_regex}.
The commit style was inspired by an Internet article on semantic commits\footnote{\url{http://karma-runner.github.io/0.10/dev/git-commit-msg.html}}.

\begin{lstlisting}[xleftmargin=18.0ex, caption=Commit Message Regex, captionpos=b, label=lst:commit_msg_regex]
^(fix|ref) #[0-9]+: [A-Z].+[\n]$
\end{lstlisting}

\subsection{Time Estimation}
Each task on the git repository would be marked with an estimation of the time required to complete the task.
Originally this estimation was supposed to be used to further improve our time estimation skills.
However, we did not have enough time to properly implemented a system that would combine our time estimations
and the time we actually spent working on the issue, which were tracked through Toggl\footnote{Toggl, timetracking application: \url{https://toggl.com/app/timer}}.
